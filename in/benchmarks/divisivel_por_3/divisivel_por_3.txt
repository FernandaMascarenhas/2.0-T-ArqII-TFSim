//  main:
    // Inicializa R1 com 34
LD R1, 0(R0)
DADDI R1, R0, 34

    // Verifica se R1 é igual a zero
BEQ R1, R0, is_zero
    // Verifica se R1 é negativo
BGEZ R1, eh_negativo
    // Verifica se R1 é positivo
BLTZ R1, eh_positivo

    // Ponto de retorno (caso algo inesperado aconteça)
J 20

 // is_zero:
    // Caso R1 seja igual a zero, atribui 1 a R1
DADDI R1, R0, 1
J 18

//eh_negativo:
    // Inicializa o registrador R2 com 3
DADDI R2, R0, 3
  
//  while_negativo_loop:
    // Verifica se R1 < 0
BGEZ R1, 3                // se for > 0 vai para exit_while_negativo, ou seja, sai do while

    // R1 += 3
DADD R1, R1, R2

    // Salta para o início do loop
J -2

//  exit_while_negativo:
    // Verifica se R1 é igual a zero
BEQ R1, R0, 3

    // Caso R1 não seja igual a zero, ou seja ele virar +, retorna -1
DADDI R1, R0, -1
J 12

//  is_zero_neg:
    // Caso R1 seja igual a zero, retorna 1
DADDI R1, R0, 1
J 10

//eh_positivo:
    // Inicializa o registrador R2 para 3
DADDI R2, R0, 3

//  while_positivo_loop:
    // Verifica se R1 > 0
BLTZ R1, 3                // se for < 0 vai para exit_while_negativo, ou seja, sai do while

    // R1 -= 3
DSUB R1, R1, R2

    // Salta para o início do loop
J -2

//  exit_while_positivo:
    // Verifica se R1 é igual a zero
BEQ R1, R0, 3

    // Caso R1 não seja igual a zero, retorna -1
DADDI R1, R0, -1
J 3

//  is_zero_pos:
    // Caso R1 seja igual a zero, retorna 1
DADDI R1, R0, 1
J 1
// FIM